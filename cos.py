# Function to measure cosine distance between face descriptors. 
import numpy as np
import matplotlib as plt

Threshold = 1.5 

def cos_distances(descriptorM: np.ndarray, 
                  descriptorN: np.ndarray) -> np.ndarray:

    #do we have to check inputs are 2d arrays
    #normalize vectors
    descriptorM_norm = descriptorM/np.linalg.norm(descriptorM, axis = 1)
    descriptorN_norm = descriptorN/np.linalg.norm(descriptorN, axis = 1)

    #find similarity using dot product 
    cos_distances = 1.0 - np.dot(descriptorM_norm, descriptorN_norm.T)

    return cos_distances

class Node:
    def __init__(self, ID, descriptor, truth=None, file_path=None):
        self.id = ID
        self.label = ID
        # self.neighbors = tuple(neighbors)
        self.descriptor = descriptor
        self.truth = truth
        self.file_path = file_path

    def get_descriptor(self):
        return self.descriptor 
    
    def get_label(self):
        return self.label
    
    def store_neighbors(self, neighbors):
        self.neighbors = neighbors

    def get_neighbors(self):
        return self.neighbors
    

    
def create_adj_matrix(descriptors):
    #first create an empty matrix with size [M, M]
    #where M is size of descriptors 
    adj_matrix = np.zeros((len(descriptors), len(descriptors)))

    #access every element of the array
    for row in range(len(descriptors)):
        for col in range(len(descriptors)):
            distance = cos_distances(descriptors[row], descriptors[col]) #This "should" return an np.array with one element
            adj_matrix[row, col] = 1/(distance[0,0])
            
            #add functionality so the exact same images arent read as the same
            if (row == col):
                adj_matrix[row, col] = 0.0
    
    #return the final weighted matrix
    return adj_matrix


def convert_descriptors_to_nodes(descriptors):
    #each id will just be the index of descriptors for simplicity 
    nodes = []
    for i in range(len(descriptors)):
        nodes.append(Node(i, descriptors[i]))

    #returns a list of nodes that have the descriptor
    return nodes

def compute_and_store_neighbors(node, nodes, adj_matrix, threshold):

    ''''
    Parameters:
    descriptor -> a single descriptor vector 
    descriptors -> a list of all descriptor vectors 
    adj_matrix -> a matrix generated by passing in descriptors 
    threshold -> the optimal value that we calculated using histograms 

    Output:
    A list of neighbor tuples where the first element of tuple is the descriptor itself and the other is the weight of that neighbor vector

    '''
    neighbors = []
    #computing the neighors for the node that you sepecify
    #first we have to find the node index in adj_matrix 
    index = 0 
    for i in range(len(nodes)):
        if (node.get_descriptor ==  nodes[i].get_descriptor):
            index = i
    
    #now we can iterate through the column and store the neighbors as an list 
    #every element of the lost is a tuple with the neighbor node itself and the weight so it doesn't get lost
    for i in range(len(nodes)): 
        if (adj_matrix[index][i] < threshold):
            neighbors.append((nodes[i], adj_matrix[index][i]))

    #store this list of tuples into the node object that was passed into it 
    node.store_neighbors(neighbors)

def plot_historgram(cos_distances, bins=50):
    '''
    cos_distances = array for cos distances (M, N)
    '''
    cos_distances = cos_distances.flatten()
    plt.hist(cos_distances, bins=bins, color = '', edgecolor = '')
    plt.xlabel("cos distance between 2 descriptors")
    plt.ylabel("count")
    plt.grid(axis='y', alpha=0.75)
    plt.title("histogram of cos distances")
    plt.show()